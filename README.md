**Написать свою реализацию ps ax используя анализ /proc**

В результате выполнения ДЗ был написан скрипт **getpsax.sh**, который анализиурет каталог `/proc` и выводит следующую информацию о процесаах:
PID, TTY, STATUS, NICE, TIME, COMMAND.

В скрипте для вывода перечилсенных характеристик процесса используются 5 функций. Функции для вывода статуса, nice'а, и команды с аргументами достаточно просты. Более подробно рассмотрим функции **pstty()** и **pstime()**.

```
pstty(){
#Считываем значение tty_nr, в котором в битах 0-7 содержится минорный номер
#устройства, а в битах 8-15 - мажорный номер устройства. Это нужно для
#определения TTY процесса, так как не все дескрипторы из /proc/$pid/fd
#ссылаются на нужный tty в каталоге /dev
        ttynr=$(awk '{print $7}' /proc/$pid/stat)
        if [ $ttynr -gt 0 ];then
#Проще всего нужные биты для определения мажорного и минорного номеров
#устройства TTY извлечь из числа в hex-нотации, тогда биты 0-7 будут
#представлены последними двумя разрядами, а 8-15 - 3м и 4м разрядами с конца 
                majorhex=$(printf '%x\n' $ttynr | rev | cut -b 3,4 | rev)
                minorhex=$(printf '%x\n' $ttynr | rev | cut -b 1,2 | rev)
#После извлечения нужных номеров переведем их обратно в dec-нотацию
                major=$(printf '%d\n' "0x$majorhex")
                minor=$(printf '%d\n' "0x$minorhex")
#Как правило мажорный номер 4 соответсвует устройству /dev/tty, а
#минорный номер - номеру этого tty.
#Мажорный номер 136 соответсвует псевдотерминалу pts, его можно извлечь из
#катлога /proc/$pid/fd
                if [ $major -eq 4 ];then
                        ttynum="tty$minor"
                elif [ $major -eq 136 ];then
                        ttynum=$(ls -l /proc/$pid/fd | grep -o "pts\/[0-9]" | head -1)
                else
                        ttynum="?"
                fi
        else
                ttynum="?"
        fi
        echo $ttynum
}
```

Функция **pstime()** вычисляет время использования CPU процессом в формате HH:MM:SS. Для её выполнения сначала необходимо выяснить, какое количество интервалов времени в секунду выделяется процессу планировщиком CPU в данной системе. Для этого в в переменную `$hertz` сохраняется результат запроса 
`getconf CLK_TCK`.

```
pstime(){
#Время CPU, которое процесс затратил в user mode (в интервалах планировщика CPU):
        utime=$(awk '{print $14}' /proc/$pid/stat)
#Время CPU, которое процесс затратил в kermel mode (в интервалах планировщика CPU):
        stime=$(awk '{print $15}' /proc/$pid/stat)
#Определим общее время CPU, потраченное на процесс (в интервалах планировщика CPU):
        sumtime=$(($utime+$stime))
#Вычислим время использования CPU процессом в формате HH:MM:SS:
        cputime=$(date -u -d @$(($sumtime/$hertz)) +"%T")
        echo $cputime
}
```

